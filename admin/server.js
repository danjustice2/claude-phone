const express = require('express');
const path = require('path');
const fs = require('fs');
const http = require('http');
const AsteriskManager = require('asterisk-manager');

const app = express();
const PORT = parseInt(process.env.ADMIN_PORT || '8080', 10);
const AMI_HOST = process.env.AMI_HOST || '127.0.0.1';
const AMI_PORT = parseInt(process.env.AMI_PORT || '5038', 10);
const AMI_SECRET = process.env.AMI_SECRET || '';
const DEVICES_CONFIG = process.env.DEVICES_CONFIG || '/app/config/devices.json';
const USERS_CONFIG = process.env.USERS_CONFIG || '/app/config/users.json';
const PJSIP_DEVICES_CONF = '/app/config/pjsip_devices.conf';
const PJSIP_USERS_CONF = '/app/config/pjsip_users.conf';
const VOICE_APP_URL = process.env.VOICE_APP_URL || 'http://127.0.0.1:3000';

let ami = null;
let amiConnected = false;

// ============================================================
// AMI Connection
// ============================================================

function connectAMI() {
  if (ami) {
    try { ami.disconnect(); } catch (e) { /* ignore */ }
  }

  ami = new AsteriskManager(AMI_PORT, AMI_HOST, 'admin', AMI_SECRET, true);

  ami.on('connect', () => {
    amiConnected = true;
    console.log(`[ADMIN] Connected to AMI at ${AMI_HOST}:${AMI_PORT}`);
  });

  ami.on('error', (err) => {
    amiConnected = false;
    console.error('[ADMIN] AMI error:', err.message);
  });

  ami.on('close', () => {
    amiConnected = false;
    console.log('[ADMIN] AMI connection closed, reconnecting in 5s...');
    setTimeout(connectAMI, 5000);
  });
}

function amiAction(action) {
  return new Promise((resolve, reject) => {
    if (!ami || !amiConnected) {
      return reject(new Error('AMI not connected'));
    }
    ami.action(action, (err, res) => {
      if (err) return reject(err);
      resolve(res);
    });
  });
}

// ============================================================
// JSON file helpers (atomic read/write)
// ============================================================

function readJsonFile(filePath) {
  if (!fs.existsSync(filePath)) return {};
  return JSON.parse(fs.readFileSync(filePath, 'utf8'));
}

function writeJsonFile(filePath, data) {
  const tmp = filePath + '.tmp';
  fs.writeFileSync(tmp, JSON.stringify(data, null, 2) + '\n', 'utf8');
  fs.renameSync(tmp, filePath);
}

function readDevicesJson() {
  return readJsonFile(DEVICES_CONFIG);
}

function writeDevicesJson(data) {
  writeJsonFile(DEVICES_CONFIG, data);
}

function readUsersJson() {
  return readJsonFile(USERS_CONFIG);
}

function writeUsersJson(data) {
  writeJsonFile(USERS_CONFIG, data);
}

// ============================================================
// PJSIP config generation (mirrors entrypoint.sh logic)
// ============================================================

function generatePjsipDevicesConf(devices) {
  let conf = '';
  conf += '; ============================================================\n';
  conf += '; Voice-app extensions (registered by drachtio)\n';
  conf += '; Auto-generated by admin panel\n';
  conf += '; ============================================================\n\n';

  for (const [ext, dev] of Object.entries(devices)) {
    const authId = dev.authId || ext;
    const password = dev.password || 'changeme';
    const name = dev.name || 'Extension ' + ext;

    conf += '; ' + name + '\n';
    conf += '[' + ext + ']\n';
    conf += 'type=endpoint\n';
    conf += 'context=claude-phone\n';
    conf += 'disallow=all\n';
    conf += 'allow=ulaw\n';
    conf += 'allow=alaw\n';
    conf += 'auth=' + ext + '-auth\n';
    conf += 'aors=' + ext + '\n';
    conf += 'direct_media=no\n\n';

    conf += '[' + ext + '-auth]\n';
    conf += 'type=auth\n';
    conf += 'auth_type=userpass\n';
    conf += 'username=' + authId + '\n';
    conf += 'password=' + password + '\n\n';

    conf += '[' + ext + ']\n';
    conf += 'type=aor\n';
    conf += 'max_contacts=1\n';
    conf += 'remove_existing=yes\n';
    conf += 'qualify_frequency=60\n\n';
  }

  return conf;
}

function generatePjsipUsersConf(users) {
  let conf = '';
  conf += '; ============================================================\n';
  conf += '; User phone extensions (for SIP softphones/desk phones)\n';
  conf += '; Auto-generated by admin panel\n';
  conf += '; ============================================================\n\n';

  for (const [ext, user] of Object.entries(users)) {
    const name = user.name || 'User ' + ext;
    const password = user.password || 'changeme';

    conf += '; ' + name + '\n';
    conf += '[' + ext + ']\n';
    conf += 'type=endpoint\n';
    conf += 'context=claude-phone\n';
    conf += 'disallow=all\n';
    conf += 'allow=ulaw\n';
    conf += 'allow=alaw\n';
    conf += 'auth=' + ext + '-auth\n';
    conf += 'aors=' + ext + '\n';
    conf += 'direct_media=no\n\n';

    conf += '[' + ext + '-auth]\n';
    conf += 'type=auth\n';
    conf += 'auth_type=userpass\n';
    conf += 'username=' + ext + '\n';
    conf += 'password=' + password + '\n\n';

    conf += '[' + ext + ']\n';
    conf += 'type=aor\n';
    conf += 'max_contacts=1\n';
    conf += 'remove_existing=yes\n';
    conf += 'qualify_frequency=60\n\n';
  }

  return conf;
}

// ============================================================
// Reload helpers
// ============================================================

async function reloadAsterisk() {
  await amiAction({ action: 'Command', command: 'module reload res_pjsip.so' });
  await amiAction({ action: 'Command', command: 'dialplan reload' });
  console.log('[ADMIN] Asterisk PJSIP + dialplan reloaded');
}

function notifyVoiceApp() {
  return new Promise((resolve) => {
    const url = new URL('/api/admin/reload', VOICE_APP_URL);
    const req = http.request(url, { method: 'POST', timeout: 5000 }, (res) => {
      let body = '';
      res.on('data', (d) => { body += d; });
      res.on('end', () => {
        try { resolve(JSON.parse(body)); } catch (e) { resolve({ success: true }); }
      });
    });
    req.on('error', (err) => {
      console.warn('[ADMIN] Voice-app reload notification failed:', err.message);
      resolve({ success: false, error: err.message });
    });
    req.end();
  });
}

async function applyChanges(type) {
  const results = { asterisk: false, voiceApp: false };

  // Regenerate pjsip conf files
  if (type === 'devices' || type === 'all') {
    const devices = readDevicesJson();
    fs.writeFileSync(PJSIP_DEVICES_CONF, generatePjsipDevicesConf(devices));
    console.log('[ADMIN] pjsip_devices.conf regenerated');
  }
  if (type === 'users' || type === 'all') {
    const users = readUsersJson();
    fs.writeFileSync(PJSIP_USERS_CONF, generatePjsipUsersConf(users));
    console.log('[ADMIN] pjsip_users.conf regenerated');
  }

  // Reload Asterisk via AMI
  if (amiConnected) {
    try {
      await reloadAsterisk();
      results.asterisk = true;
    } catch (err) {
      console.error('[ADMIN] Asterisk reload failed:', err.message);
    }
  }

  // Notify voice-app to reload device registry
  if (type === 'devices' || type === 'all') {
    const voiceResult = await notifyVoiceApp();
    results.voiceApp = voiceResult.success !== false;
  }

  return results;
}

// ============================================================
// Validation helpers
// ============================================================

function validateDevice(body, isUpdate) {
  const errors = [];
  if (!isUpdate) {
    if (!body.extension) errors.push('extension is required');
    else if (!/^\d{4,5}$/.test(body.extension)) errors.push('extension must be 4-5 digits');
    else if (parseInt(body.extension) < 9000 || parseInt(body.extension) > 99999) errors.push('device extension must be >= 9000');
    if (!body.name) errors.push('name is required');
    if (!body.password || body.password.length < 4) errors.push('password must be at least 4 characters');
  } else {
    if (body.password !== undefined && body.password.length < 4) errors.push('password must be at least 4 characters');
    if (body.extension !== undefined) errors.push('extension cannot be changed');
  }
  return errors;
}

function validateUser(body, isUpdate) {
  const errors = [];
  if (!isUpdate) {
    if (!body.extension) errors.push('extension is required');
    else if (!/^\d{4}$/.test(body.extension)) errors.push('extension must be exactly 4 digits');
    else if (parseInt(body.extension) >= 9000) errors.push('user extension must be < 9000');
    if (!body.name) errors.push('name is required');
    if (!body.password || body.password.length < 4) errors.push('password must be at least 4 characters');
  } else {
    if (body.password !== undefined && body.password.length < 4) errors.push('password must be at least 4 characters');
    if (body.extension !== undefined) errors.push('extension cannot be changed');
  }
  return errors;
}

// ============================================================
// Middleware
// ============================================================

app.use(express.json());
app.use(express.static(path.join(__dirname, 'public')));

// ============================================================
// Dashboard / Status endpoints
// ============================================================

app.get('/api/status', async (req, res) => {
  const status = {
    ami: amiConnected,
    timestamp: new Date().toISOString()
  };

  if (amiConnected) {
    try {
      // CoreSettings returns version; CoreStatus returns startup info + current calls
      const [coreSettings, coreStatus] = await Promise.all([
        amiAction({ action: 'CoreSettings' }),
        amiAction({ action: 'CoreStatus' })
      ]);

      // Compute uptime from startup date/time
      let uptime = 'unknown';
      const startupDate = coreStatus.corestartupdate;
      const startupTime = coreStatus.corestartuptime;
      if (startupDate && startupTime) {
        const startMs = new Date(startupDate + ' ' + startupTime).getTime();
        if (!isNaN(startMs)) {
          const diffSec = Math.floor((Date.now() - startMs) / 1000);
          const days = Math.floor(diffSec / 86400);
          const hours = Math.floor((diffSec % 86400) / 3600);
          const mins = Math.floor((diffSec % 3600) / 60);
          const parts = [];
          if (days > 0) parts.push(days + 'd');
          if (hours > 0) parts.push(hours + 'h');
          parts.push(mins + 'm');
          uptime = parts.join(' ');
        }
      }

      status.asterisk = {
        version: coreSettings.asteriskversion || coreSettings.coreversion || 'unknown',
        uptime: uptime,
        startupDate: startupDate || 'unknown',
        startupTime: startupTime || 'unknown',
        currentCalls: parseInt(coreStatus.corecurrentcalls || '0', 10)
      };
    } catch (err) {
      status.asterisk = { error: err.message };
    }
  }

  res.json(status);
});

app.get('/api/endpoints', async (req, res) => {
  if (!amiConnected) {
    return res.json({ error: 'AMI not connected', endpoints: [] });
  }

  try {
    const cmdResult = await amiAction({
      action: 'Command',
      command: 'pjsip show endpoints'
    });

    const output = cmdResult.content || cmdResult.output || '';
    const lines = output.split('\n');
    const endpoints = [];

    for (const line of lines) {
      const match = line.match(/^\s*([\w]+)\/[\w]+\s+\S+\s+(\w+)/);
      if (match) {
        endpoints.push({
          extension: match[1],
          status: match[2].toLowerCase()
        });
      }
    }

    res.json({ endpoints });
  } catch (err) {
    res.json({ error: err.message, endpoints: [] });
  }
});

app.get('/api/channels', async (req, res) => {
  if (!amiConnected) {
    return res.json({ error: 'AMI not connected', channels: [] });
  }

  try {
    const cmdResult = await amiAction({
      action: 'Command',
      command: 'core show channels concise'
    });

    const output = cmdResult.content || cmdResult.output || '';
    const channels = [];
    const lines = output.split('\n').filter(l => l.trim());

    for (const line of lines) {
      const parts = line.split('!');
      if (parts.length >= 5) {
        channels.push({
          channel: parts[0],
          context: parts[1],
          extension: parts[2],
          state: parts[4]
        });
      }
    }

    res.json({ channels });
  } catch (err) {
    res.json({ error: err.message, channels: [] });
  }
});

// Hangup a channel
app.post('/api/channels/:channel/hangup', async (req, res) => {
  if (!amiConnected) {
    return res.status(503).json({ error: 'AMI not connected' });
  }

  try {
    await amiAction({
      action: 'Hangup',
      channel: req.params.channel
    });
    res.json({ success: true });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// ============================================================
// Device CRUD
// ============================================================

app.get('/api/devices', (req, res) => {
  try {
    const devices = readDevicesJson();
    const list = Object.entries(devices).map(([ext, dev]) => ({
      extension: ext,
      name: dev.name || ext,
      authId: dev.authId || ext,
      voiceId: dev.voiceId || '',
      prompt: dev.prompt || '',
      hasPassword: !!dev.password
    }));
    res.json({ devices: list });
  } catch (err) {
    res.status(500).json({ error: err.message, devices: [] });
  }
});

app.get('/api/devices/:extension', (req, res) => {
  try {
    const devices = readDevicesJson();
    const dev = devices[req.params.extension];
    if (!dev) return res.status(404).json({ error: 'Device not found' });
    res.json({
      extension: req.params.extension,
      name: dev.name || req.params.extension,
      authId: dev.authId || req.params.extension,
      voiceId: dev.voiceId || '',
      prompt: dev.prompt || '',
      hasPassword: !!dev.password
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

app.post('/api/devices', async (req, res) => {
  const errors = validateDevice(req.body, false);
  if (errors.length) return res.status(400).json({ errors });

  try {
    const devices = readDevicesJson();
    const ext = req.body.extension;

    // Check uniqueness across both devices and users
    const users = readUsersJson();
    if (devices[ext]) return res.status(409).json({ error: 'Device extension already exists' });
    if (users[ext]) return res.status(409).json({ error: 'Extension already used by a user' });

    devices[ext] = {
      name: req.body.name,
      extension: ext,
      authId: req.body.authId || ext,
      password: req.body.password,
      voiceId: req.body.voiceId || '',
      prompt: req.body.prompt || ''
    };

    writeDevicesJson(devices);
    const reload = await applyChanges('devices');
    res.status(201).json({ success: true, extension: ext, reload });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

app.put('/api/devices/:extension', async (req, res) => {
  const errors = validateDevice(req.body, true);
  if (errors.length) return res.status(400).json({ errors });

  try {
    const devices = readDevicesJson();
    const ext = req.params.extension;
    if (!devices[ext]) return res.status(404).json({ error: 'Device not found' });

    // Update only provided fields
    if (req.body.name !== undefined) devices[ext].name = req.body.name;
    if (req.body.authId !== undefined) devices[ext].authId = req.body.authId;
    if (req.body.password !== undefined) devices[ext].password = req.body.password;
    if (req.body.voiceId !== undefined) devices[ext].voiceId = req.body.voiceId;
    if (req.body.prompt !== undefined) devices[ext].prompt = req.body.prompt;

    writeDevicesJson(devices);
    const reload = await applyChanges('devices');
    res.json({ success: true, extension: ext, reload });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

app.delete('/api/devices/:extension', async (req, res) => {
  try {
    const devices = readDevicesJson();
    const ext = req.params.extension;
    if (!devices[ext]) return res.status(404).json({ error: 'Device not found' });

    if (Object.keys(devices).length <= 1) {
      return res.status(400).json({ error: 'Cannot delete the last device' });
    }

    delete devices[ext];
    writeDevicesJson(devices);
    const reload = await applyChanges('devices');
    res.json({ success: true, extension: ext, reload });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// ============================================================
// User CRUD
// ============================================================

app.get('/api/users', (req, res) => {
  try {
    const users = readUsersJson();
    const list = Object.entries(users).map(([ext, user]) => ({
      extension: ext,
      name: user.name || 'User ' + ext,
      hasPassword: !!user.password
    }));
    res.json({ users: list });
  } catch (err) {
    res.status(500).json({ error: err.message, users: [] });
  }
});

app.get('/api/users/:extension', (req, res) => {
  try {
    const users = readUsersJson();
    const user = users[req.params.extension];
    if (!user) return res.status(404).json({ error: 'User not found' });
    res.json({
      extension: req.params.extension,
      name: user.name || 'User ' + req.params.extension,
      hasPassword: !!user.password
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

app.post('/api/users', async (req, res) => {
  const errors = validateUser(req.body, false);
  if (errors.length) return res.status(400).json({ errors });

  try {
    const users = readUsersJson();
    const ext = req.body.extension;

    // Check uniqueness across both users and devices
    const devices = readDevicesJson();
    if (users[ext]) return res.status(409).json({ error: 'User extension already exists' });
    if (devices[ext]) return res.status(409).json({ error: 'Extension already used by a device' });

    users[ext] = {
      name: req.body.name,
      extension: ext,
      password: req.body.password
    };

    writeUsersJson(users);
    const reload = await applyChanges('users');
    res.status(201).json({ success: true, extension: ext, reload });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

app.put('/api/users/:extension', async (req, res) => {
  const errors = validateUser(req.body, true);
  if (errors.length) return res.status(400).json({ errors });

  try {
    const users = readUsersJson();
    const ext = req.params.extension;
    if (!users[ext]) return res.status(404).json({ error: 'User not found' });

    if (req.body.name !== undefined) users[ext].name = req.body.name;
    if (req.body.password !== undefined) users[ext].password = req.body.password;

    writeUsersJson(users);
    const reload = await applyChanges('users');
    res.json({ success: true, extension: ext, reload });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

app.delete('/api/users/:extension', async (req, res) => {
  try {
    const users = readUsersJson();
    const ext = req.params.extension;
    if (!users[ext]) return res.status(404).json({ error: 'User not found' });

    delete users[ext];
    writeUsersJson(users);
    const reload = await applyChanges('users');
    res.json({ success: true, extension: ext, reload });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// ============================================================
// System management
// ============================================================

app.post('/api/asterisk/reload', async (req, res) => {
  if (!amiConnected) {
    return res.status(503).json({ error: 'AMI not connected' });
  }

  try {
    // Regenerate both conf files and reload
    const reload = await applyChanges('all');
    res.json({ success: true, reload });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

app.post('/api/voice-app/reload', async (req, res) => {
  try {
    const result = await notifyVoiceApp();
    res.json(result);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// ============================================================
// Start server
// ============================================================

app.listen(PORT, '0.0.0.0', () => {
  console.log(`[ADMIN] Claude Phone admin panel listening on port ${PORT}`);

  if (AMI_SECRET) {
    connectAMI();
  } else {
    console.warn('[ADMIN] No AMI_SECRET configured, AMI features disabled');
  }
});
